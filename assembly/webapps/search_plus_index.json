{"./":{"url":"./","title":"关于smartboot","keywords":"","body":"关于smartboot 一个人的开源组织。 作品 smart-socket 仅用一千多行代码实现极简、易用、高性能的java AIO通信框架，也许是IM、RPC、IoT开发的最佳选择 smart-http 采用smart-socket作为通信内核实现的Http服务器。 smart-boot 基于springboot封装的微服务框架。（目前工作中无使用机会，基本已成僵尸项目） somart-ioc Java NIO实现的smart-socket android 版通信框架 maven-mydalgen-plugin mybatis代码自动生成的Maven插件，简化sql书写，避免大量动态sql。 成员 三刀 一个写了十年代码的老菜鸟，希望下一个十年能去掉“菜”这个标签。过去一半的工作经历都是外包，现在稳定就职于某电商平台。工作中专注于业务，工作外沉浸于技术。 如何加入smartboot组织 方式一：捐赠smartboot ￥1,000,000。 方式二： 发表smartboot任一项目文章并获得1W以上的阅读量，不限平台。 开源作者或为开源作出过贡献。 smartboot成员认可。 Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-11-20 19:20:53 "},"smart-socket/":{"url":"smart-socket/","title":"前言","keywords":"","body":"介绍 smart-socket是一款历史比较悠久的开源项目，可追溯的最早历史痕迹可至2015年。 直到2017年夏天它才进入大众的视野并有了点小名气，正是在那一年smart-socket完成了nio往aio的转型。 由于其极简、易用、高性能的特性吸引了一些用户的青睐，并在开源社区的助推下发展至 v1.4版。 smart-socket的定位是只做最纯粹的通信框架，只要是Java语言的通信开发需求，它都能满足你。 如今smart-socket已经广泛应用于物联网领域，用户选择它的理由基本是：稳定、上手快。 事实上掌握smart-socket并不依赖本教程，因为它简单到只有两个接口的学习成本。 考虑到有些朋友初次接触通信编程，还是需要一份使用教程辅助学习，故特地撰写了此文。 当然个人能力有限，本书中描述的内容难免会有错漏之处，还望读者朋友谅解并及时反馈至作者（zhengjunweimail@163.com）加以订正。希望读完本书后你能有所收获，祝大家阅读愉快！ Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-07-02 21:24:59 "},"smart-socket/chapter-1/2.1-基础应用/":{"url":"smart-socket/chapter-1/2.1-基础应用/","title":"1.1 快速上手","keywords":"","body":"快速上手 JDK1.7 是采用 smart-socket 进行开发的最低版本要求，如果您还在用 JDK1.6 或者更低的版本，请先升级您的 JDK。 如果您从事的是 Android 通信开发，可能会面临低版本系统而无法使用 smart-socket 的问题，为此我们专为采用 NIO 技术开发了 Android 版本通信框架 smart-ioc，因其不属于本章主角故暂不多做介绍。 除了JDK，建议事先准备一款顺手的IDE，并搭建好Maven环境，会有更高的开发效率。 smart-socket 并不依赖除 slf4j-api 之外的其他第三方 jar 包，所以你可以很轻易的将它集成到你的项目中，无需担心会发生 jar 包冲突的问题。 得益于 smart-socket 代码量极少的特性，你甚至可以选择直接将源码拷贝到自己的项目中，维护一个专属于你的私有版 smart-socket。 目前 smart-socket 托管在码云和Github，有需要的可前往下载项目源码。 码云 https://gitee.com/smartboot/smart-socket GITHUB https://github.com/smartboot/smart-socket 不过我们更推荐的是采用 maven 方式引用 smart-socket ，这样便可享受由作者提供后续的版本升级服务。 org.smartboot.socket aio-core 1.4.5 线程模型 用户选择通信框架通常是为了满足服务端的开发，毕竟客户端通信比较简单，即便是传统的BIO都是个性价比较高的选项。所以本书会更侧重于分享 smart-socket 在服务端通信方面的实践，在动手编码之前希望读者朋友先仔细理解下图描绘的 smart-socket 服务端线程模型，对于之后的学习、应用有很大的帮助。 smart-socket 服务端内部设有三类线程： Accept线程 接受客户端的连接请求，完成连接会话（AioSession）实例化后便开始监听客户端的数据请求。 Worker线程组 Worker线程是一组线程池，该线程的职责主要是处理服务端的读写事件。其中读事件的处理会相对复杂，涉及到已读数据的解码（decode）、业务处理（process）和响应数据输出（write）操作。 Watchman线程 顾名思义，该线程充当监工的角色，监视的对象是Worker线程组待处理的任务。该线程只能处理读回调（read callback）事件，它的存在意义在于激活可能正处于休眠状态的 Worker 线程继续工作。 内存池 内存池大家应该并不陌生，在 smart-socket 中维护了一套内存池为通信服务提供性能与稳定性的支撑。关于 smart-socket 内存池在后文有详细的介绍，此处先为读者阐述内存池中的几个基本概念以及它们之间的关系，见下图。 内存池：BufferPool 一个内存池中包含了多个内存页BufferPage，为内存申请源提供内存页的分配策略，并且运行着低优先级异步任务将未使用的内存块chunk回收至内存页BufferPage。 内存页：BufferPage 其本质就是一个由用户指定大小的 ByteBuffer 对象，DirectByteBuffer 和 HeapByteBuffer 皆可。通过事先初始化足够大小的内存页，服务运行期间可快速响应内存需求。 内存块：chunk 从 BufferPage 中划分出来的小块内存以满足通信所需，内存块的的申请尽量遵循按需申请，用完即还原则。当内存页中剩余空间不足以满足申请源需求大小时，smart-socket 将向 JVM 申请临时内存块。 线程模型和内存池两者相辅相成，构建出了一个完成的通信内核。熟练掌握并加以合理的应用，所编写的通信服务便会有着非常出色的表现。 接下里我们正式为大家演示如果运用 smart-socket 进行基本的通信开发。 1.1.1 工程搭建 本章以Maven工程为例为大家演示基于smart-socket实现socket开发，如果您已经有现成的工程仅需引入pom.xml依赖即可，否则请先建立一个项目工程。 4.0.0 org.smartboot.socket demo 1.0-SNAPSHOT org.smartboot.socket aio-core 1.4.5 org.slf4j slf4j-simple 1.7.25 此处我们选用了 smart-socket 目前的最新包：aio-core 1.4.5。出于精简 pom 依赖和不绑架用户对日志框架选择权考虑，smart-socket 非常贴心的仅依赖 slf4j-api，所以开发人员可以自由选择任意的日志框架集成到项目中。例如本次的示例工程我们引入 slf4j-simple 依赖以便观察运行时日志。 1.1.2 协议约定 工程搭建完毕后，还需适当了解一下通信开发的基础知识：协议。作者接触不少刚开始写通信程序的开发，他们普遍存在的问题是没有正确理解\"协议\"的概念，以及\"协议\"在整个通信过程中所扮演的\"信息翻译官\"这个非常重要的角色。 通信中所说的协议是指双方实体完成通信或服务所必须遵循的规则和约定。 协议定义了数据单元使用的格式，信息单元应该包含的信息与含义，连接方式，信息发送和接收的时序，从而确保网络中数据顺利地传送到确定的地方。 协议的制定，需要满足三要素： 语法：约定通信的数据格式，编码，信号等级 语义：在语法的基础上传递的数据内容 定时规则：明确通信内容的时序 下面我们来定义一套简单的通信协议，并基于该协议实现服务端与客户端的信息交互。如下图所示，每个单元格表示一个Byte，整个消息由两部分组成： 消息头：固定一个byte长度 消息体：根据消息体中的数值决定消息体长度。当N等于1，消息体长度也则为1；当N等于10，消息体长度则为10。 按照上述规则，我们可以得出一个公式：消息长度=消息头长度+消息体长度，而消息体的长度取决于消息头中的数值。这就是所谓的协议，那根据这个协议，我们如何实现传输呢？ 以字符串“socket”为例，按照上述协议进行编码后的结果为： 该协议采用smart-socket可用如下算法实现解码： 标志当前buffer的postion位置； 获取本次消息的消息体长度，position递增1位； 判断当前已读的数据长度是否满足消息体长度； 出现半包，数据不完整，重置标志位，并返回null终止本次解码； buffer中包含完整的消息体内容，则进行读取，postiton=postion+增加消息体长度; 更新标志位 将已读数据转换为字符串并返回，解码成功。 public class StringProtocol implements Protocol { public String decode(ByteBuffer buffer, AioSession session) { buffer.mark(); // 1 byte length = buffer.get(); // 2 if (buffer.remaining() 同样的协议可以有不同的解析算法，不同算法的优劣各不相同。依旧以此协议为例，解析算法还能这样写： 采用绝对定位的方式识别消息长度，该读取方式不会改变buffer的position值； 判断当前buffer中待读取的数据长度是否满足消息体长度；不满足条件说明存在半包情况，返回null； 若消息数据完整，构建用于存放数据的byte数组，通过执行buffer.get()设置数组长度。此get方法会对buffer的position作加1操作。 再次执行buffer.get方法，以byte数组为入参接受消息体数据，此操作也会影响buffer的position； 构建字符串对象，解码成功。 public class StringProtocol implements Protocol { @Override public String decode(ByteBuffer readBuffer, AioSession session) { byte length = readBuffer.get(readBuffer.position());//1 if (length+1 1.1.3 服务端 ​启动服务端需要依赖AioQuickServer，实际应用中的运行参数调优也都是对AioQuickServer的接口进行操作， 此处先展示一下它的基本应用。 构造服务端对象AioQuickServer。该类的构造方法有以下几个入参： port，服务端监听端口号，客户度要请求该端口号才可连上服务端。 Protocol，协议解码类，将ByteBuffer中已读部分的byte数据还原成消息实体 MessageProcessor，消息处理器，对Protocol解析出来的消息进行业务处理 启动Server服务 public class Server { public static void main(String[] args) throws IOException { // 1 AioQuickServer server = new AioQuickServer(8080, new StringProtocol(), new MessageProcessor() { public void process(AioSession session, String msg) { System.out.println(\"接受到客户端消息:\" + msg); byte[] response = \"Hi Client!\".getBytes(); byte[] head = {(byte) response.length}; try { session.writeBuffer().write(head); session.writeBuffer().write(response); } catch (IOException e) { e.printStackTrace(); } } public void stateEvent(AioSession session, StateMachineEnum stateMachineEnum, Throwable throwable) { } }); //2 server.start(); } } 上述代码中启动了端口号8080的服务端应用，当接收到客户端发送过来的数据时，服务端以StringProtocol进行协议解码，识别出客户度传递的字符串，随后将该消息转交给消息处理器MessageProcessor进行业务处理。 1.1.4 客户端 客户端的开发相较于服务端就简单很多，仅需操作一个连接会话（AioSession）即可，而服务端面向的是众多连接会话，在实际运用中还得具备并发思维与会话资源管理策略。客户端的开发步骤通常如下： 连接服务端，取得连接会话（AioSession） 发送请求消息 处理响应消息 关闭客户端 public class Client { public static void main(String[] args) throws InterruptedException, ExecutionException, IOException { AioQuickClient client = new AioQuickClient(\"127.0.0.1\", 8080, new StringProtocol(), new MessageProcessor() { public void process(AioSession session, String msg) { System.out.println(msg); } public void stateEvent(AioSession session, StateMachineEnum stateMachineEnum, Throwable throwable) { } }); AioSession session = client.start(); byte[] msgBody = \"Hello Server!\".getBytes(); byte[] msgHead = {(byte) msgBody.length}; try { session.writeBuffer().write(msgHead); session.writeBuffer().write(msgBody); session.writeBuffer().flush(); } catch (IOException e) { e.printStackTrace(); } } } 1.1.5 启动运行 完成代码的编写后我们便可先后启动服务端、客户端程序，观察通信服务的运行结果。服务端启动成功后，会在控制台打印如下信息，如启动失败请检查是否存在端口被占用的情况。 ​ 接下来我们再启动客户端程序，客户端启动成功后会直接发送一个“Hello Server!”的消息给服务端，并通过消息处理器(MessageProcessor)打印所接受到的服务端响应消息“Hi Client!”。 至此，我们采用 smart-socket 顺利完成了简易的通信服务。如果对本章节某个知识点还不甚清楚，建议反复阅读加深理解或者上网搜索同类信息。当然，跟着示例动手敲一遍代码也是个不错的学习方式。 Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-11-21 18:54:08 "},"smart-socket/chapter-1/2.2-Spring集成/":{"url":"smart-socket/chapter-1/2.2-Spring集成/","title":"1.2 Spring集成smart-socket","keywords":"","body":"Spring集成smart-socket 现今的企业系统开发通常会使用Spring，smart-socket与Spring的集成就是一个基本的通信服务Bean实例托管的过程。 此处以xml配置和注解两种方式为大家介绍smart-socket于spring的集成方案，前期需要做的准备工作就是先搭建一个spring工程，并引入smart-socket依赖，pom.xml配置如下图。 1. xml配置化启动服务 ​ 通过2.1章节我们了解到smart-socket启用通信服务依赖两个关键的要素：Protocol、MessageProcessor，在spring的集成应用中我们依旧需要定义它们的实现类。接下来我们会以服务端场景为例给大家演示，如果您是要进行客户端通信服务与Spring的集成，请按同样的操作方式替换一下相应的配置即可。 定义协议类 public class StringProtocol implements Protocol { @Override public String decode(ByteBuffer readBuffer, AioSession session) { int remaining = readBuffer.remaining(); if (remaining readBuffer.remaining()) { readBuffer.reset(); return null; } byte[] b = new byte[length]; readBuffer.get(b); readBuffer.mark(); return new String(b); } } 定义处理器 public class ServerProcessor implements MessageProcessor { @Override public void process(AioSession session, String msg) { WriteBuffer writeBuffer = session.writeBuffer(); byte[] bytes = msg.getBytes(); try { writeBuffer.writeInt(bytes.length); writeBuffer.write(bytes); } catch (IOException e) { e.printStackTrace(); } } @Override public void stateEvent(AioSession session, StateMachineEnum stateMachineEnum, Throwable throwable) { } } 准备工作就绪后，我们需要在application.xml配置它们的实例bean，并将其引用至AioQuickServer的bean配置。因为AioQuickServer的构造方法都是带参数的，所以配置bean的时候需要用到标签constructor-arg。 当启动spring容器时，我们的通信服务便开始运行。 接下来我们来验证一下集成后的效果，如果将其配置到真正的web服务中演示过程稍显琐碎，故我们直接通过main函数来调用。 public class SpringDemo { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"application.xml\"); AioQuickServer aioQuickServer = context.getBean(\"aioQuickServer\", AioQuickServer.class); System.out.println(\"服务启动成功：\" + aioQuickServer); ((ClassPathXmlApplicationContext) context).close(); System.out.println(\"服务关闭\"); } } 执行上述代码后控制台会打印服务的启动与关闭日志，如果出现异常，请检查端口号是否被占用。 2. 注解方式启动服务 如果读者习惯用注解的方式使用Spring，那我们需要对原有的代码稍加改动。Protocol和MessageProcessor实现类需要加上注解@Component。 定义协议类 @Component(\"protocol\") public class StringProtocol implements Protocol { @Override public String decode(ByteBuffer readBuffer, AioSession session) { int remaining = readBuffer.remaining(); if (remaining readBuffer.remaining()) { readBuffer.reset(); return null; } byte[] b = new byte[length]; readBuffer.get(b); readBuffer.mark(); return new String(b); } } 定义处理器 @Component(\"messageProcessor\") public class ServerProcessor implements MessageProcessor { @Override public void process(AioSession session, String msg) { WriteBuffer writeBuffer = session.writeBuffer(); byte[] bytes = msg.getBytes(); try { writeBuffer.writeInt(bytes.length); writeBuffer.write(bytes); } catch (IOException e) { e.printStackTrace(); } } @Override public void stateEvent(AioSession session, StateMachineEnum stateMachineEnum, Throwable throwable) { } } 接下来我们修改application.xml配置，default-autowire=\"byName\"表示优先按bean名称注入，而注解的扫描扫描包路径为org.smartboot.example.spring。 最后我们还需要以注解的形式构造AioQuickServer对象并启动服务。 @Component public class SpringDemo { @Autowired private MessageProcessor messageProcessor; @Autowired private Protocol protocol; private AioQuickServer aioQuickServer; public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"application.xml\"); SpringDemo demo = context.getBean(\"springDemo\", SpringDemo.class); System.out.println(\"服务启动成功：\" + demo.aioQuickServer); ((ClassPathXmlApplicationContext) context).close(); System.out.println(\"服务关闭\"); } @PostConstruct public void init() { aioQuickServer = new AioQuickServer(8080, protocol, messageProcessor); try { aioQuickServer.start(); } catch (IOException e) { e.printStackTrace(); } } @PreDestroy public void destroy() { aioQuickServer.shutdown(); } } Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-07-07 13:05:12 "},"smart-socket/chapter-1/SUMMARY.html":{"url":"smart-socket/chapter-1/SUMMARY.html","title":"小结","keywords":"","body":"小结 本章为大家演示了smart-socket最基础的应用，可以看到该框架相较于其它知名NIO框架（具备代表性的AIO框架不多，暂且不论），开发起来的代码量和难度都是比较低的。 接下来我们会对smart-socket进行更深入的剖析，感兴趣的读者朋友可继续往下看，如果结合smart-socket的源码阅读效果更佳。 Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-07-02 21:58:08 "},"smart-socket/chapter-2/":{"url":"smart-socket/chapter-2/","title":"第二章 源码解析","keywords":"","body":"第三章 smart-socket源码解析 smart-socket的源码部分主要分三部分：基础通信、TLS/SSL通信、内存池。本章只分享基础通信部分的内容，这部分对于绝大多数的开发人员都是比较有意义的。而TLS/SSL比较复杂，作者自认很难以通俗易懂的文字给读者讲解清楚，对于高级开发人员而言通过看源码应该能领悟一些门道，故本书暂不提及此部分内容。内存池是smart-socket 1.4 加入的新特性，是作者在研究 Netty 内存池却始终无法领悟其精髓后决定自研的一套模型，在第四章中有详细的说明。 考虑到smart-socket在版本迭代中会有一些细小变化，本章会筛选核心的部分进行代码解读。 如果在实际中发现文章内容与代码有出入，则以你当前所使用的版本为准。 smart-socket的整体代码结构如下所示。 Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-07-07 12:53:45 "},"smart-socket/chapter-2/核心接口/":{"url":"smart-socket/chapter-2/核心接口/","title":"2.1 核心接口与状态机","keywords":"","body":"核心接口与状态机 业界有句话叫“一流的卖标准、二流的卖技术、三流的卖产品”， 如果说 smart-socket 的技术价值仅算二流水准的话， 那么我们为其精心设计的接口期望能稍微提升一下它的档次。 基于 smart-socket 进行通信开发的主要工作量基本集中在两个接口的实现：Protocol、MessageProcessor。 两个接口分工很明确，Protocol 负责解析数据形成消息实体，之后 smart-socket 会把该消息实体传递至 MessageProcessor 进行业务处理。 当然，你也可以在 Protocol 中一次性完成解析、业务处理，又或者将 Protocol 当个摆设，所有事情集中在 MessageProcessor 完成。smart-socket 不限制你实现功能的自由性，只是提供一个更规范、更合理的建议，最终决定权还是在用户的手中。 1. Protocol public interface Protocol { T decode(final ByteBuffer readBuffer, AioSession session); } Protocol 是一个泛型接口，指的是业务消息实体类，smart-socket 中不少地方都运用了泛型设计，其含义都代表数据解码后封装的消息类型。Protocol 中只定义了一个方法decode。 decode（消息解码），AIO 的数据传输是以 ByteBuffer 为媒介的。所有读取到的字节数据都会填充在 ByteBuffer 中并以事件回调的形式触发 Protocol#decode() 方法。所以我们实现的 decode 算法就是 ByteBuffer 对象转化为业务消息的过程。 需要强调一点，读者朋友请不要把解码想的很简单，令人“深恶痛绝”的半包/粘包就是在这个环节需要应对的。处理方式也不难，遵守以下两点即可： 根据协议解析每一个字段前，都要先确保剩余数据满足解析所需，不满足则终止该字段解析并返回 null。 当已读的数据已满足一个完整业务消息所需时，立即构造该业务对象并返回，无需关心 ByteBuffer 中是否有剩余的数据。 考虑到有些读者对上述两点还不甚理解，我们通过两个示例来模拟通信过程中的半包、粘包场景。通信协议依旧是如1.1节中的定义的类型： 半包 public class StringProtocol implements Protocol { public static void main(String[] args) { StringProtocol protocol = new StringProtocol(); byte[] msgBody = \"smart-socket\".getBytes(); byte msgHead = (byte) msgBody.length; System.out.println(\"完整消息长度:\" + (msgBody.length + 1)); ByteBuffer buffer = ByteBuffer.allocate(msgBody.length); buffer.put(msgHead); buffer.put(msgBody, 0, buffer.remaining()); buffer.flip(); System.out.println(protocol.decode(buffer, null)); } public String decode(ByteBuffer buffer, AioSession session) { buffer.mark(); byte length = buffer.get(); if (buffer.remaining() 根据协议规定，完整的消息长度是字符串“smart-socket”字节数加一个字节的消息头，即13位。但因接收数据的 ByteBuffer 空间不足导致无法容纳整个消息，此时执行解码算法decode便等同于通信中的半包，运行后控制台打印如下： 完整消息长度:13 半包：期望长度:12 ,实际剩余长度:11 null 粘包 public class StringProtocol implements Protocol { public static void main(String[] args) { StringProtocol protocol = new StringProtocol(); byte[] msgBody = \"smart-socket\".getBytes(); byte msgHead = (byte) msgBody.length; System.out.println(\"完整消息长度:\" + (msgBody.length + 1)); ByteBuffer buffer = ByteBuffer.allocate((msgBody.length + 1) * 2); //第一个消息 buffer.put(msgHead); buffer.put(msgBody); //第二个消息 buffer.put(msgHead); buffer.put(msgBody); buffer.flip(); String str = null; while ((str = protocol.decode(buffer, null)) != null) { System.out.println(\"消息解码成功:\"+str); } } public String decode(ByteBuffer buffer, AioSession session) { if (!buffer.hasRemaining()) { return null; } buffer.mark(); byte length = buffer.get(); if (buffer.remaining() 粘包出现于已读数据的部分超过了一个完整的消息长度。如 demo 所示，我们在 ByteBuffer 中放入了符合协议贵的两个完整消息，按照解码算法解析出第一个消息里立即返回new String(body)，待该消息处理完成后再进行下一次解码。故上述例子的控制台打印如下： 完整消息长度:13 消息解码成功:smart-socket 消息解码成功:smart-socket 至此我们已经为大家介绍了 Protocol 的特性以及对于半包粘包的处理方式，当然真实场景下我们会面临更复杂的协议，对于半包粘包的处理方式也是多种多样，在通信协议章节在详细说明。 2. MessageProcessor public interface MessageProcessor { /** * 处理接收到的消息 * * @param session 通信会话 * @param msg 待处理的业务消息 */ void process(AioSession session, T msg); /** * 状态机事件,当枚举事件发生时由框架触发该方法 * * * @param session 本次触发状态机的AioSession对象 * @param stateMachineEnum 状态枚举 * @param throwable 异常对象，如果存在的话 * @see StateMachineEnum */ void stateEvent(AioSession session, StateMachineEnum stateMachineEnum, Throwable throwable); } Protocol 侧重于通信层的数据解析，而 MessageProcessor 则负责应用层的消息业务处理。定义了消息处理器接口，smart-socket 在通过 Protocol 完成消息解码后，会将消息对象交由 MessageProcessor 实现类进行业务处理。 process 消息处理器，smart-socket 每接收到一个完整的业务消息，都会交由该处理器执行。 stateEvent 执行状态机，smart-socket 内置了状态枚举StateMachineEnum。MessageProcessor实现类可在此方法中处理其关注的事件。 3. 状态机StateMachineEnum smart-socket中 引入了状态机的概念，状态机的存在不会决策 smart-socket 对于通信的事件处理，但会在特定事件发生之时通知消息处理器MessageProcessor#stateEvent。目前已有的状态枚举为： 状态枚举 说明 NEW_SESSION 网络连接建立时触发，连接建立时会构建传输层的AioSession，如果业务层面也需要维护一个会话，可在此状态机中处理 INPUT_SHUTDOWN 数据读取完毕时触发，即传统意义中的read()==-1 INPUT_EXCEPTION 读数据过程中发生异常时触发此状态机 OUTPUT_EXCEPTION 写数据过程中发生异常时触发此状态机 SESSION_CLOSING 触发了AioSession.close方法，但由于当前AioSession还有未完成的事件，会进入SESSION_CLOSING状态 SESSION_CLOSED AioSesson完成close操作后触发此状态机 PROCESS_EXCEPTION 业务处理异常 DECODE_EXCEPTION 解码异常 REJECT_ACCEPT 服务端拒绝客户端连接请求 状态机伴贯穿了通信服务的整个生命周期，在这个过程中不同事件的发生会触发不同的状态机。通信事件与状态机的关系如下图所示。 图2.2.2 状态机相对于整个通信环境的各个节点只是一个旁观者，它见证了各个事件的发生，却无力扭转事件的发展方向。状态机本质其实跟大家所认知的过滤器、拦截器有点类似，那为什么smart-socket要如此设计呢？想想一下如果我们按照过滤器的设计思路，其形态会如下所示： public interface Filter{ void newSession(AioSesion session); void processException(AioSession session,Throwable throwable); void decodeExcepton(AioSession session,Throwable throwable); void inputException(AioSession session,Throwable throwable); void outputException(AioSession session,Throwable throwable); void sessionClosing(AioSession session); void sessionClosed(AioSession session); } 这样的设计存在以下缺陷： 对实现类不友好；也许我只想处理 newSession，却不得不保留其余方法的空实现； 无法平滑升级；加入新版本中加入新的事件类型，老版本代码需要全部更改； 而采用状态机模式，不仅解决了上述问题，还为通信服务的多元化扩展带了便利。 例如 IM 场景下，我们在 NEW_SESSION 状态机中收集 Session 集合，在消息处理时很容易就能实现消息群发； 当某个用户断线后，我们及时在状态机 SESSION_CLOSED 中感知到并更新 Session 集合中的会话状态，甚至可以群发消息给所有用户“某某人掉线了”。这些通信状态和业务相结合的场景， 用状态机能很好的得以解决。最后奉上一段粗糙的伪代码，读者自行领悟。 public class IMProcessor implements MessageProcessor { private LinkedBlockingQueue sessions = new LinkedBlockingQueue(); public void process(AioSession session, Message msg) { for(AioSession otherSession:sessions){ if(otherSession==session){ continue; } sendMessage(otherSession,session+\"群发送消息：\"+msg); } } public void stateEvent(AioSession session, StateMachineEnum state, Throwable throwable) { switch (state) { case NEW_SESSION: sessions.add(session); break; case SESSION_CLOSED: sessions.remove(session); break; } } } Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-11-21 21:08:55 "},"smart-socket/chapter-2/服务端/":{"url":"smart-socket/chapter-2/服务端/","title":"2.2 服务端","keywords":"","body":"服务端AioQuickServer 异步非阻塞通信的服务端实现。这个类主要是对JDK提供的AIO通信类AsynchronousServerSocketChannel、AsynchronousChannelGroup进行封装。AioQuickServer是服务端通信的调度中心，在完成协议、消息处理器的定义后，需要通过AioQuickServer来启动我们的通信服务。AioQuickServer提供了一些必要的参数配置接口，方便开发人员进行资源分配以达到最优效果。 2.5.1 成员属性 属性名 类型 说明 serverSocketChannel AsynchronousServerSocketChannel JDK提供的AIO服务端核心类 asynchronousChannelGroup AsynchronousChannelGroup JDK为AIO提供的线程池服务 config IoServerConfig 存储AioQuickServer服务配置项 aioReadCompletionHandler ReadCompletionHandler smart-socket提供的IO读回调处理类 aioWriteCompletionHandler WriteCompletionHandler smart-socket提供的IO写回调处理类 bufferPool BufferPagePool 内存池对象 workerExecutorService ThreadPoolExecutor Worker线程池 2.5.2 配置接口 方法 说明 public AioQuickServer setBannerEnabled(boolean bannerEnabled) 服务启动时是否打印smart-socket banner public AioQuickServer setThreadNum(int num) Server服务线程数 public AioQuickServer setReadBufferSize(int size) 设置AioSession读缓存区长度 public AioQuickServer setOption(SocketOption socketOption, V value) 设置Socket的TCP参数配置 2.5.3 核心方法 2.5.3.1 start：启动AIO服务端 片段一 asynchronousChannelGroup = AsynchronousChannelGroup.withFixedThreadPool(config.getThreadNum(), new ThreadFactory() { byte index = 0; @Override public Thread newThread(Runnable r) { return new Thread(r, \"smart-socket:AIO-\" + (++index)); } }); 初始化AIO服务的工作线程组并赋值于AioQuickServer成员属性asynchronousChannelGroup 片段二 this.serverSocketChannel = AsynchronousServerSocketChannel.open(asynchronousChannelGroup).bind(new InetSocketAddress(config.getPort()), 1000); 这行代码很直观，打开AIO服务通道并绑定端口号，但要注意bind方法。AsynchronousServerSocketChannel提供了两个bind接口：bind(SocketAddress local)，bind(SocketAddress local, int backlog) 如果调用bind(SocketAddress local)方法，AsynchronousServerSocketChannel内部实际上执行的是bind(SocketAddress local, 0)。然而backlog的值小于1时，JDK会将其默认设置为50。 backlog维护了连接请求队列长度，如果队列满时收到连接指示，则拒绝该连接。举个例子：backlog设置为50，当前有50连接请求过来，服务端还未执行这些连接请求的accept方法。此时再有一个连接请求过来，则会被拒绝连接。除非请求队列中的某个连接完成accept操作并释放出队列资源，服务器才可接受新的连接。 片段三 acceptThread = new Thread(new Runnable() { NetMonitor monitor = config.getMonitor(); @Override public void run() { while (running) { Future future = serverSocketChannel.accept(); try { final AsynchronousSocketChannel channel = future.get(); workerExecutorService.execute(new Runnable() { @Override public void run() { if (monitor == null || monitor.acceptMonitor(channel)) { createSession(channel); } else { config.getProcessor().stateEvent(null, StateMachineEnum.REJECT_ACCEPT, null); LOGGER.warn(\"reject accept channel:{}\", channel); closeChannel(channel); } } }); } catch (Exception e) { LOGGER.error(\"AcceptThread Exception\", e); } } } }, \"smart-socket:AcceptThread\"); acceptThread.start(); protected void createSession(AsynchronousSocketChannel channel) { //连接成功则构造AIOSession对象 AioSession session = null; try { session = aioSessionFunction.apply(channel); session.initSession(); } catch (Exception e1) { LOGGER.debug(e1.getMessage(), e1); if (session == null) { try { channel.shutdownInput(); } catch (IOException e) { LOGGER.debug(e.getMessage(), e); } try { channel.shutdownOutput(); } catch (IOException e) { LOGGER.debug(e.getMessage(), e); } try { channel.close(); } catch (IOException e) { LOGGER.debug(\"close channel exception\", e); } } else { session.close(); } } } smart-socket通过启动AcceptThread线程同步监听客户端连接请求， 一旦客户端连接上来便生成异步任务由WorkerThread线程池来初始化AioSession。 所有的AioSession共用aioReadCompletionHandler、aioWriteCompletionHandler对象，这样可以减少服务端产生的对象数。 2.5.3.2 shutdown：停止AIO服务端 AIO服务停止的逻辑很简单，关闭Channel通道，停止线程组。 public final void shutdown() { running = false; try { if (serverSocketChannel != null) { serverSocketChannel.close(); serverSocketChannel = null; } } catch (IOException e) { LOGGER.warn(e.getMessage(), e); } if (!workerExecutorService.isTerminated()) { try { workerExecutorService.shutdownNow(); } catch (Exception e) { LOGGER.error(\"shutdown exception\", e); } } if (!asynchronousChannelGroup.isTerminated()) { try { asynchronousChannelGroup.shutdownNow(); } catch (IOException e) { LOGGER.error(\"shutdown exception\", e); } } try { asynchronousChannelGroup.awaitTermination(3, TimeUnit.SECONDS); } catch (InterruptedException e) { LOGGER.error(\"shutdown exception\", e); } } Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-07-07 14:06:53 "},"smart-socket/chapter-2/客户端/":{"url":"smart-socket/chapter-2/客户端/","title":"2.3 客户端","keywords":"","body":"客户端AioQuickClient 在过去我不曾觉得框架对于提供客户端API有多重要，因为即便采用最传统的BIO技术也能满足我们的业务所需。 直到从事互联网开行业后才意识到一个问题，随着业务的发展会在系统中存在大量的RPC服务，所以服务调用方可能会创建几十甚至上百个客户端连接。 如果继续采用BIO技术，单单通信所需的线程资源都会对系统运行造成巨大负担。 而运用AIO技术可以实现客户端通信线程资源共享，仅需少量线程便可支持几百上千的客户端连接。 smart-socket提供的客户端服务AioQuickClient在代码实现上比较简单，并且尽量让必要的事情都在构造方法中完成，核心的几个要素只有host、port、protocol、messageProcessor。 如仅需以下几行代码便完成客户端的创建、通信、关闭。 public class IntegerClient { public static void main(String[] args) throws Exception { AioQuickClient aioQuickClient = new AioQuickClient(\"localhost\", 8888, new IntegerProtocol(), new IntegerClientProcessor()); AioSession session = aioQuickClient.start(); session.writeBuffer().writeInt(1); Thread.sleep(1000); aioQuickClient.shutdown(); } } 在smart-socket中实现客户端AioQuickClient功能的代码量非常少，最复杂的逻辑也就是start方法。 在客户端中存在两个start方法，两者的区别在于线程资源是独享还是共享的。值得注意的是，执行start后会返回当前客户端的AioSession对象，如此一来建立创建成功后可直接进行数据输出。 public final AioSession start() throws IOException, ExecutionException, InterruptedException { this.asynchronousChannelGroup = AsynchronousChannelGroup.withFixedThreadPool(2, new ThreadFactory() { @Override public Thread newThread(Runnable r) { return new Thread(r); } }); return start(asynchronousChannelGroup); } public AioSession start(AsynchronousChannelGroup asynchronousChannelGroup) throws IOException, ExecutionException, InterruptedException { AsynchronousSocketChannel socketChannel = AsynchronousSocketChannel.open(asynchronousChannelGroup); if (bufferPool == null) { bufferPool = new BufferPagePool(IoServerConfig.getIntProperty(IoServerConfig.Property.CLIENT_PAGE_SIZE, 1024 * 256), 1, IoServerConfig.getBoolProperty(IoServerConfig.Property.CLIENT_PAGE_IS_DIRECT, true)); } //set socket options if (config.getSocketOptions() != null) { for (Map.Entry, Object> entry : config.getSocketOptions().entrySet()) { socketChannel.setOption(entry.getKey(), entry.getValue()); } } //bind host if (localAddress != null) { socketChannel.bind(localAddress); } socketChannel.connect(new InetSocketAddress(config.getHost(), config.getPort())).get(); //连接成功则构造AIOSession对象 session = new AioSession(socketChannel, config, new ReadCompletionHandler(), new WriteCompletionHandler(), bufferPool.allocateBufferPage()); session.initSession(); return session; } Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-07-07 13:48:45 "},"smart-socket/chapter-2/AioSession/":{"url":"smart-socket/chapter-2/AioSession/","title":"2.4 会话AioSession","keywords":"","body":"通信会话AioSession ​ AioQuickServer和AioQuickClient在smart-socket中负责的是服务的配置、启动、停止，所以代码逻辑较简单。AioSession才是smart-socket真正的灵魂，它是衔接网络传输与业务应用的纽带。在AioSession的协调控制下，用户无需再去关心并发所带来的复杂IO场景，只需专注于数据编解码与业务处理。 ​ AioSession我们只讲解跟用户息息相关的部分，其余部分读者可自行去阅读源码。AIO通信的关键两个环节为：读回调、写回调，smart-socket对这两个事件的处理都在AioSession中实现。随着版本的迭代，读者在本文看到的代码可能与实际项目源码中看到的可能略有差异，但主体结构是一致的。我们先来看一下读回调的处理过程： 调用flip方法将接收数据的缓冲区切换至读模式。 执行ioServerConfig.getProtocol().decode()进行数据解析。若无法解析出一个完整的消息则返回null，结束本次解析操作；若在解析过程中出现异常会触发状态机PROCESS_EXCEPTION，在这个环节出现异常通常是因为接收到了非法数据，此类问题的常见处理方式为关闭当前网络。 如果成功解析出一个业务消息，会执行消息处理器messageProcessor.process(this, dataEntry)。这个阶段出现的运行时异常并不影响原网络传输中的数据有效性，所以smart-socket对异常进行了捕获并依旧以状态机PROCESS_EXCEPTION的形式反馈给用户。 完成业务处理后若缓冲区中还存留未解析的数据，会再次执行解码（步骤2）、业务处理（步骤3）操作。 byteBuf中存放了业务处理后待发送的数据，执行flush进行数据输出。 监测当前AioSession状态，如若已不可用则结束。 若AioSession依旧处于可用状态，则切换缓冲区至写状态，并触发读操作continueRead。 void readFromChannel(boolean eof) { final ByteBuffer readBuffer = this.readBuffer.buffer(); readBuffer.flip(); final MessageProcessor messageProcessor = ioServerConfig.getProcessor(); while (readBuffer.hasRemaining()) { T dataEntry = null; try { dataEntry = ioServerConfig.getProtocol().decode(readBuffer, this); } catch (Exception e) { messageProcessor.stateEvent(this, StateMachineEnum.DECODE_EXCEPTION, e); throw e; } if (dataEntry == null) { break; } //处理消息 try { messageProcessor.process(this, dataEntry); } catch (Exception e) { messageProcessor.stateEvent(this, StateMachineEnum.PROCESS_EXCEPTION, e); } } if (byteBuf != null && !byteBuf.isClosed()) { byteBuf.flush(); } if (eof || status == SESSION_STATUS_CLOSING) { close(false); messageProcessor.stateEvent(this, StateMachineEnum.INPUT_SHUTDOWN, null); return; } if (status == SESSION_STATUS_CLOSED) { return; } //数据读取完毕 if (readBuffer.remaining() == 0) { readBuffer.clear(); } else if (readBuffer.position() > 0) { // 仅当发生数据读取时调用compact,减少内存拷贝 readBuffer.compact(); } else { readBuffer.position(readBuffer.limit()); readBuffer.limit(readBuffer.capacity()); } continueRead(); } 写操作的回调代码实现相对简单很多，但事实上却是处理难度最大的。因为写操作是个主动行为，我们不可预知用户在何时会写入数据，而写缓冲区中积压的数据又要依靠smart-socket将其输出到网络对端，故此处就存在并发的情况。如果出现多个线程同时触发write操作会导致WritePendingException，在AioSession中使用了信号量Semaphore完成了同步控制，实现了数据有序的输出。smart-socket的写回调会执行writeToChannel方法，而这信号量在之前已经通过其他途径被锁定，此处暂且不提。回调的处理逻辑为： 识别writeBuffer或缓冲集合bufList中是否存在待输出的数据，若有则继续执行写操作continueWrite()。 如果数据已经输出完毕，则释放信号量。 如果当前AioSession处于不可用状态，则关闭当前会话。 由于并发的因素可能在释放信号量之后又有数据被写进来，且会话依旧处于可用状态，则当前线程会去竞争信号量资源，并在成功获取到信号量后执行数据输出。 void writeToChannel() { if (writeBuffer == null) { writeBuffer = byteBuf.bufList.poll(); } else if (!writeBuffer.buffer().hasRemaining()) { writeBuffer.clean(); writeBuffer = byteBuf.bufList.poll(); } if (writeBuffer != null) { continueWrite(writeBuffer); return; } semaphore.release(); //此时可能是Closing或Closed状态 if (status != SESSION_STATUS_ENABLED) { close(); } else if (!byteBuf.isClosed()) { //也许此时有新的消息通过write方法添加到writeCacheQueue中 byteBuf.flush(); } } 若想了解smart-socket完整的写操作处理逻辑，请阅读源码WriteBuffer.java。 Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-07-07 14:07:57 "},"smart-socket/chapter-2/SUMMARY.html":{"url":"smart-socket/chapter-2/SUMMARY.html","title":"2.5 小结","keywords":"","body":"小结 源码永远是最好的教程，善于读源码和debug朋友掌握smart-socket完全是轻而易举的事。源码是作者设计理念最直观的展现，这也是开源的魅力所在。\"talk is cheap show me the code\"，开源让技术难题的探讨变得更加务实，正如smart-socket，在您看完源码后心中对它都会有一个定论。在作者看来，smart-socket切切实实降低了通信开发学习门槛，也保障了服务的高性能、高可用。如果读者朋友对源码中某些部分的设计存在疑虑，也欢迎与作者保持沟通。 Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-07-07 14:08:36 "},"smart-socket/chapter-3/":{"url":"smart-socket/chapter-3/","title":"第三章 通信协议","keywords":"","body":"第三章 通信协议 \"协议\"这个词在本文中反复提及，通信领域中的”协议“等同于人们日常所认知的协议概念，例如：保密协议，就业协议等。协议是对双方行为准则的约束，任何一方背离既定协议规则，都会导致双方的关系出现问题。现实生活的中的协议形态可能是一纸文书，又或者是双方口头达成的共识，而在通信领域中协议是双方对传输/接受数据流的编解码实现算法。 众所周知，数据在网络上是以字节流的形式传输（如若较真点也可以说是二进制流），而字节的定义是在所有计算机语言中定义的都是8bit。所以只要通过协议不仅可以翻译网络中数据流的业务含义，又可实现跨计算机语言的通信。从事通信开发的朋友要谨记我们要面向协议编程，在开发过程中遇到问题切勿再质疑是否跟对方所使用的语言有关系？而是要确定对方是否准守通信协议，自己又是否准守了通信协议。 目前业界已经存在大量的标准协议支撑了整个互联网世界，诸如：Http，FTP，SMTP，MQTT，而私有协议更多。所谓“私有协议”指由双方自行约定编解码规则的协议，而非业界公认的通信规范。本章节我们会带着大家一起学习协议的正确处理方式，尽管编解码不是一件难事，但对于新手朋友这也并不简单。如果您对于半包、粘包的处理方式还不甚了解，不妨好好阅读本章内容，以后也请勿抛出此类问题，因为这比较”不专业“。 Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-07-07 13:12:00 "},"smart-socket/chapter-3/1-消息归类/":{"url":"smart-socket/chapter-3/1-消息归类/","title":"3.1 消息归类","keywords":"","body":"消息归类 在正式讲解之前我们先来对常见的几种消息进行分类，方便大家理解消化。后续在工作终于遇到问题时可按照本文定义的类别寻找相应的解决方法。注意，此处讲的是“消息”，并非协议，可能有人疑惑这两者的区别。用面向对象的思想简单理解就是：协议等同于class，消息就是class实例化后的object。为了便于区分，我们将消息分类以下几种： 1. 一类消息 服务端与客户端之间通信的所有消息大小都是在一定范围内的，AIOSession的readBuffer容量完全可以承载至少一个消息（前提是readBuffer的容量本身就设置了一个“合理”的数值）。这个“合理”的定义是ReadBuffer容量尽可能的满足绝大部分消息长度，且数值不会超过一定阈值。假设我们暂定readBuffer的容量阈值为1024，那么以下几种消息则属于一类消息： 所有消息长度都小于100，readBuffer设置容量为100 消息长度范围[0,512)，readBuffer容量设置为512 消息长度范围[0,1024),readBuffer容量设置为1024 那如果消息长度范围为[0,2048)呢，我们是否可以通过将readBuffer容量设置为2048来满足我们的需求？答案是否定的，如果绝大部分情况下消息大小在1024内，仅少量的消息大小在[1024,2048)区间内，扩大readBuffer容量会导致缓存空间利用率不高，这对于内存资源是一直浪费。所以存在此类情况的消息不属于“一类消息”。 2. 二类消息 假设readBuffer的容量阈值依旧是1024，绝大部分消息长度都未超过该范围，但是偶尔有几个消息长度超过了1024，此为二类消息。二类消息的定义还存在一个限制条件，尽管消息长度超过了1024，但是不可超的太离谱。当我们认为一个消息因太长，导致无法完整的进行内存存储时，我们将其定义为“三类消息”。 现在先介绍一下二类消息的处理方式，譬如我们定义的readBuffer容量为512byte，这已经满足99%消息的容量需求，但可能存在1%的消息长度会超过这阈值，我们姑且将这消息长度定义为600byte。针对此类消息，在解码时需要申请一个足够容量的临时缓冲区用于存放当前消息的字节数组，这个临时缓冲区可能是个固定长度的大缓冲区，又可能是个可自动扩容的缓冲区。 或许读者朋友会问，为什么smart-socket的readBuffer不提供自动扩容缓冲区的能力？那是由于框架无法识别消息的有效性，一旦遭遇恶意攻击或者用户滥用可扩容的读缓冲区，会造成内存方面不可预知的异常情况。smart-socket在设计之初便非常重视服务的稳定性，对于用户技能水平的要求也会略高于某些同类通信框架，由此也导致smart-socket的使用体验稍显逊色。如果要在迎合用户的使用体验与服务可靠性之间做一个选择，smart-socket选择后者，毕竟技能水平的提升每个从业人员必要的坚持。 几乎绝大多数协议或者协议中某个字段约定的解析规则就两种：定长协议、特定结束符解析。接下里分别介绍两种类型的处理方式，为了方便举例，我们将缓冲区容量定义为8byte。在处理二类消息的过程中我们会引用到aio-pro提供的解码器，所以读者朋友在使用前请先在pom.xml中引入aio-pro的依赖。 org.smartboot.socket aio-pro 1.4.X 定长协议 协议格式： 字段 含义 长度 length 消息头，其值表示消息体长度 1字节 data 消息体 length值 根据上述协议，假设客户端发送的消息为：9abcdefjhi，第一位消息头”9“为byte类型，占用了1字节，后续的消息体“abcdefjhi”占用了9字节，所以服务端本次收到的消息长度为：10字节。由于读缓冲区的长度限制为8，则“9abcdefg”便填满了缓冲区，需要先将其读取完后再去读“hi”。编解码算法如下所示： public class FixedLengthProtocol implements Protocol { @Override public String decode(ByteBuffer readBuffer, AioSession session) { if (!readBuffer.hasRemaining()) { return null; } FixedLengthFrameDecoder fixedLengthFrameDecoder; if (session.getAttachment() != null) { fixedLengthFrameDecoder = session.getAttachment(); } else { byte length = readBuffer.get();//获得消息体长度 fixedLengthFrameDecoder = new FixedLengthFrameDecoder(length);//构建指定长度的临时缓冲区 session.setAttachment(fixedLengthFrameDecoder);//缓存临时缓冲区 } if (!fixedLengthFrameDecoder.decode(readBuffer)) { return null;//已读取的数据不足length，返回null } //数据读取完毕 ByteBuffer fullBuffer = fixedLengthFrameDecoder.getBuffer(); byte[] bytes = new byte[fullBuffer.remaining()]; fullBuffer.get(bytes); session.setAttachment(null);//释放临时缓冲区 return new String(bytes); } } 定长消息的处理核心在于通过FixedLengthFrameDecoder开辟一块足够容量的临时缓冲区，待读取完整的有效数据后再进行后续的解码操作。 特定结束符协议 协议格式： 字段 含义 长度 data 消息体 未知 endFlag 结束符 endFlag的字节长度 相较于定长协议，此类协议在解码结束之前都无法知晓消息的长度，直到读取到结束符标志，则此前所有已读的数据方可组成一个完整的消息或消息字段。例如按行发送的字符串数据：abc\\r\\n123\\r\\n，以\\r\\n作为结束符发送了两个消息：abc，123。 public class DelimiterProtocol implements Protocol { //结束符\\r\\n private static final byte[] DELIMITER_BYTES = new byte[]{'\\r', '\\n'}; @Override public String decode(ByteBuffer buffer, AioSession session) { DelimiterFrameDecoder delimiterFrameDecoder; if (session.getAttachment() == null) {//构造指定结束符的临时缓冲区 delimiterFrameDecoder = new DelimiterFrameDecoder(DELIMITER_BYTES, 64); session.setAttachment(delimiterFrameDecoder);//缓存解码器已应对半包情况 } else { delimiterFrameDecoder = session.getAttachment(); } //未解析到DELIMITER_BYTES则返回null if (!delimiterFrameDecoder.decode(buffer)) { return null; } //解码成功 ByteBuffer byteBuffer = delimiterFrameDecoder.getBuffer(); byte[] bytes = new byte[byteBuffer.remaining()]; byteBuffer.get(bytes); session.setAttachment(null);//释放临时缓冲区 return new String(bytes); } } 3. 三类消息 此类消息的特点就是消息体非常大，已经不适合进行内存存储了。例如文件上传类的Http消息，此时完整的消息可能小则几兆，大的则以G为单位。不过本节讲解三类消息不会以Http为例，因为Http是个相对比较复杂的协议，在真实场景中可能是二类消息、三类消息的混合式解码。此处以定长协议来传输一个100MB的文件。 协议格式： 字段 含义 长度 length 消息头，其值表示消息体长度 4字节 data 消息体 length值 100MB=104857600byte，转换成4字节的内存存储如下所示，后面的”?“代表文件的字节码。在识别出文件长度后，通过AioSession.getInputStream封装流对象并返回消息对象，之后在消息处理器中再获取BigObject的流对象便可将整个文件内容读取出来。需要注意的事，一旦使用了AioSession.getInputStream接口，则当前连接的数据读取便切换为同步阻塞模式，所以在完成读取或异常之前会占用当前线程资源，但优点以极低的内存消耗实现超大消息的解析。 public class BigObject { private InputStream inputStream; public BigObject(InputStream inputStream) { this.inputStream = inputStream; } public InputStream getInputStream() { return inputStream; } } public class BigObjectProtocol implements Protocol { @Override public BigObject decode(ByteBuffer readBuffer, AioSession session) { if (readBuffer.remaining() 提问：如果通信的所有消息都固定在1MB的大小，则此类消息算哪一种？ Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-07-07 14:08:59 "},"smart-socket/BLANK.html":{"url":"smart-socket/BLANK.html","title":"3.2 半包/粘包","keywords":"","body":"未完待续，或Star本项目后加群：830015805 Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-07-02 21:45:40 "},"smart-socket/chapter-5/":{"url":"smart-socket/chapter-5/","title":"第四章 内存池","keywords":"","body":"第四章 内存池 内存池似乎已经当下各个牛逼框架的标配，我们也专门为smart-socket度身打造了一款内存池解决方案。当然我们并不是为了盲目跟风，确实是有一些问题需要通过该项技术得以解决，并且smart-socket的内存池表现非常令人满意。在此跟大家分享一下smart-socket内存池的设计理念，但愿能与读者朋友产生共鸣。 smart-socket引入内存池设计，主要为了解决两个问题：零拷贝、对象复用。 零拷贝； 接触过Netty的朋友应该都听说过该项技术，这项技术的原理也很简单。在数据传输时，如果存储数据的ByteBuffer是堆内缓冲区对象HeapByteBuffer，则在输出时JVM会将该缓冲区的数据拷贝到堆外的直接缓冲区DirectByteBuffer再输出，该场景就存在一次内存拷贝。而如果一开始我们就将数据写入直接缓冲区DirectByteBuffer，则无需进行数据拷贝便可输出数据，这就是所谓的零拷贝，而零拷贝所带来的好处就是节省了临时内存和CPU的消耗，以下便是JVM执行数据输出的处理方式，阅读源码有助于读者朋友更深刻的理解零拷贝。 static int write(FileDescriptor var0, ByteBuffer var1, long var2, NativeDispatcher var4) throws IOException { if (var1 instanceof DirectBuffer) { return writeFromNativeBuffer(var0, var1, var2, var4); } else { int var5 = var1.position(); int var6 = var1.limit(); assert var5 0) { var1.position(var5 + var9); } var10 = var9; } finally { Util.offerFirstTemporaryDirectBuffer(var8); } return var10; } } 复用对象； 实现对象的复用一方面可以节省对象构造造成的时间成本，另一方面可以大大减少运行过程中产生的对象数，缓解GC压力。特别对于直接缓冲区DirectByteBuffer对象，不仅创建耗时长，而且因其存在于堆外内存中导致无法通过垃圾回收器释放内存，非常适合通过池化管理提升对象复用率。 4.1 设计原理 ​ smart-socket内存池的设计原理比较简单，事先在堆外内存中申请一个大的DirectByteBuffer，后续使用时通过DirectByteBuffer映射出实际所需大小的虚拟Buffer于堆内空间中。所以这VirtualBuffer其实就是堆外内存在堆内内存中创建的一个索引，smart-socket在堆内空间中对VirtualBuffer的一切数据读写操作都会同步反应至堆外的DirectByteBuffer中。 图4-1-1 接下来通过几张图示范一下内存池的运作流程。例如： 我们需要一块长度为2的ByteBuffer，那么我们就映射出一个VirtualBuffer占用堆外内存中的两个字节空间。 之后我们还需要一块长度为4的ByteBuffer，那就只能申请下标3至6的空间。 图4-1-2 当虚拟内存使用完毕后，要及时释放占用的堆外内存。 图4-1-3 下一次再需要空间时继续从可用空间中申请。 图4-1-4 ​ 通过不断的申请、释放，smart-socket内存池便运转起来了。需要注意的事，内存的申请是从头到尾进行扫描，而释放回收是无时序的，如图4-1-4。所以在实际运行中会产生一些不连续的小内存块，也就是内存碎片。内存碎片化是个必然存在的状况，假如这种小颗粒内存碎片占比增高，会降低虚拟内存申请的成功率。如果虚拟内存申请失败，smart-socket内存池会启用备用方案,采用申请堆内缓冲区的方式满足应用所需，此类缓冲区使用完毕后可由垃圾回收器释放。这样一种堆外为主，堆内为辅的设计方案，保障了smart-socket内存池的稳定、高效。 4.2 内存池实践 ​ 前文讲完了smart-socket内存池的设计原理，但在实践中还会面临一个情况，便是内存分配、回收时面临的并发问题。尽管只需加同步锁控便能解决，但是在高并发场景下的锁竞争会比较激烈，为了缓解这一状况。smart-socket内存池中引入了内存页BufferPage的概念。内存池中创建一组BufferPage，每个BufferPage各自封装一个大的DirectByteBuffer。再根据特定的分配策略将网络会话AIOSession与某个BufferPage关联起来，由此降低并发情况下的锁竞争压力。 ​ 最终我们的smart-socket内存池实现如下所示。初始化内存池时需要指定内存页的个数，为每个内存页分配的空间大小，以及是否使用直接缓冲区。至于内存页的分配，采用的是轮训策略。 public class BufferPagePool { private BufferPage[] bufferPageList; /** * 内存页游标 */ private int cursor = -1; /** * @param pageSize 内存页大小 * @param poolSize 内存页个数 * @param isDirect 是否使用直接缓冲区 */ public BufferPagePool(final int pageSize, final int poolSize, final boolean isDirect) { bufferPageList = new BufferPage[poolSize]; for (int i = 0; i 4.3 总结 ​ smart-socket内存池的设计可能在理论层面的探讨会更有意义，它所带来的性能提升和内存优化，很轻易的就会被实际业务场景下的系统业务抵消掉。而smart-socket花费大量精力设计的内存池，是为了达到实验室环境下的最优解。框架层面做的每一次努力，都是期望让更多的硬件资源服务于用户的业务，提升资源利用率。 Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:47:13 "},"smart-socket/chapter-6/":{"url":"smart-socket/chapter-6/","title":"第五章 未来规划","keywords":"","body":"应用范围 smart-socket没能赶上互联网发展的最好时机，但有机会搭上物联网发展的高速列车。目前已有不少从事物联网的企业采用smart-socket搭建属于自己的物联网络，相信接下来smart-socket还会有更广阔的应用空间。当然作为一款TCP通信框架，它的适用场景也不限于此，如果您对重复造轮子感兴趣，或许可以颠覆很多现有的解决方案，例如Http服务器、RPC通信框架、即时通讯、游戏开发、网络中间件等。 smart-socket于2017年开源，还是一个非常年轻的项目。从一开始的个人开源项目，到后来的企业级通信解决方案，仅用了不到一年的时间。当然还有很多朋友正处于观望阶段，Netty依旧是大家心目中的首选，但我们坚信smart-socket还有无限的可能性，甚至有朝一日可能如同netty一样成为世界级的项目。但无论未来的路怎样，作为smart-socket的作者，必将不忘初心，坚定项目品质不松懈。 社区发展 从事软件开发的朋友应该会有这样的感受，我们所要学习的技术绝大部分都来源于国外。而学习途径要么是直接阅读官方文档，要么购买中文书籍。两者都存在一些弊端，不少从业人员的英语水平有限，直接阅读英文文档无论效率还是效果都无法得到保障。至于购买的书籍，绝大部分都是对官方文档的翻译，或者只能掌握基本的入门知识。而smart-socket作为一款国产的开源项目，不仅提供了纯中文的参考资料，而且任何人都可以很方便的加入我们的交流社群，所有疑问都能得到及时答复。不仅如此，smart-socket还是基于了国人最朴实的思维方式而设计的，我们并不追求炫技式的设计模式，只期望已最直白的方式实现我们想要的国产通信框架。 无论您还是不是smart-socket的用户，都欢迎加入我们的社群，很期望听到更多的声音，让smart-socket不断的挖掘出自己的潜力，未来走的更稳、更远。 Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-07-07 14:09:37 "},"smart-socket/end/":{"url":"smart-socket/end/","title":"附录","keywords":"","body":"附录 smart-socket参数配置 配置参数名 功能说明 smart-socket.session.writeChunkSize 输出缓存chunk大小 smart-socket.bufferPool.pageNum 内存池中的缓存页个数 smart-socket.server.pageSize 服务端缓存页大小 smart-socket.client.pageSize 客户端缓存页大小 smart-socket.server.page.isDirect 内存池是否使用直接缓冲区 关于作者 花名：三刀 个人简介：一个写了十年代码的老菜鸟，希望下一个十年能去掉“菜”这个标签。过去一半的工作经历都是外包，现在稳定就职于某电商平台。我们公司还要招人！没错，这是一条招聘广告！ E-mail：zhengjunweimail@163.com 辛辛苦苦写了这么多，是不是应该请作者喝杯咖啡。 Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-04-14 20:38:02 "},"smart-http/":{"url":"smart-http/","title":"关于smart-http","keywords":"","body":"关于smart-http smart-http 是一款采用 Java 语言编写的 Http 服务器，有别于业界知名的 Web容器：Tomcat、Undertow，smart-http 并不支持 Servlet 规范，但对于处理 Http 请求所需的各项能力，它都具备。 smart-http 天生就是异步非阻塞的 I/O 模型，因为其通信内核采用了 smart-socket。所以无论是性能还是稳定性，都是非常出色的。 在 4核 2.9GHz 的电脑下压测的 QPS 可达 73W，流量传输效率每秒突破百兆。 smart-http 的诞生源于 smart-socket 的\"野心\"，一直以来 smart-socket 都是以业界优秀的通信框架为目标在不断的提升自己。 并且有幸接触到 TechEmpower，一个标准性能测试平台。 由于参与性能评测需要使用 Http 协议，而彼时 smart-socket 只完成基本通信功能，并未提供业界主流协议的适配。 为了能够有个清晰的自我了解，才开启 smart-http 的漫漫研发路。 个人很欣赏一句话：一个人可以走的很快，但一群人可以走的很远。 将 smart-http 开源出来，是期望这个项目能帮到一些人，同时吸收大家对它提出的发展建议，让 smart-http 和中意它的用户可以共同进步。 对于技术，我们一直是敬畏的；而对于学习，要时刻保持谦卑。还是那句话：开源不易，前行且珍惜。 Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2020-04-01 22:27:20 "},"smart-http/chapter-1/":{"url":"smart-http/chapter-1/","title":"1.1 快速上手","keywords":"","body":"快速上手 JDK1.7 是采用 smart-http 进行开发的最低版本要求，并且我们推荐采用 maven 方式将 smart-http 依赖引入您的工程中。 org.smartboot.http smart-http-server 1.0.14-SNAPSHOT 下图为 smart-http 的工程架构，我们基于 smart-socket 实现了 Http 协议的解析和请求的处理逻辑。 HttpRequest 和 HttpResponse 定义了 http 请求/响应的操作接口，HttpBootstrap 提供了配置、启动 http 服务的能力， 而用户只需要在 HttpHandler 中实现自身业务逻辑，并将其注册至 HttpBootStrap 便可。 用实际代码演示 http 服务的开发如下所示。 public class SimpleSmartHttp { public static void main(String[] args) { HttpBootstrap bootstrap = new HttpBootstrap(); bootstrap.pipeline().next(new HttpHandle() { @Override public void doHandle(HttpRequest request, HttpResponse response) throws IOException { response.write(\"hello world\".getBytes()); } }); bootstrap.setPort(8080).start(); } } 启动程序后打开浏览器访问：http://127.0.0.1，页面中会输出：Hello World 小结 通过以上描述我们看到用 smart-http 进行 http 服务开发是非常简单的。 当然在实际场景下我们面临的情况会更为复杂，例如：请求路由、静态资源服务、文件上传/下载等。 我们会尽可能的为大家整理这些场景的处理方案，无所谓教程，分享交流而已。 Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2020-04-02 13:21:42 "},"smart-http/chapter-1/http_route.html":{"url":"smart-http/chapter-1/http_route.html","title":"1.2 请求路由","keywords":"","body":"请求路由 熟悉 Servlet 或者 Spring MVC 开发的人应该对这个不陌生， 前端请求的不同接口，需要路由到不同 Servlet 或者 Controller 中进行处理。 smart-http 也提供了请求路由的支持，使用时需要用到HttpRouteHandle。 public class HttpRouteDemo { public static void main(String[] args) { //1. 实例化路由Handle HttpRouteHandle routeHandle = new HttpRouteHandle(); //2. 指定路由规则以及请求的处理实现 routeHandle.route(\"/\", new HttpHandle() { @Override public void doHandle(HttpRequest request, HttpResponse response) throws IOException { response.write(\"smart-http\".getBytes()); } }).route(\"/test1\", new HttpHandle() { @Override public void doHandle(HttpRequest request, HttpResponse response) throws IOException { response.write((\"test1\").getBytes()); } }).route(\"/test2\", new HttpHandle() { @Override public void doHandle(HttpRequest request, HttpResponse response) throws IOException { response.write((\"test2\").getBytes()); } }); // 3. 启动服务 HttpBootstrap bootstrap = new HttpBootstrap(); bootstrap.pipeline().next(routeHandle); bootstrap.start(); } } 当然，如果 smart-http 默认提供的路由组件满足不了你的需求，用户也可以通过继承HttpHandle自己实现一套请求路由算法。 Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2020-04-01 23:03:06 "},"smart-http/chapter-1/file_upload.html":{"url":"smart-http/chapter-1/file_upload.html","title":"1.3 文件上传/下载","keywords":"","body":"文件上传/下载 Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-11-30 20:39:04 "},"smart-http/chapter-1/websocket.html":{"url":"smart-http/chapter-1/websocket.html","title":"1.4 WebSocket","keywords":"","body":"WebSocket 采用 smart-http 进行 websocket 开发与普通 http 请求差别不大， Http 开发涉及到的接口在 WebSocket 中都有与之相对应的实现，见下表。 差异 Http WebSocket 请求 HttpRequest WebSocketRequest 响应 HttpResponse WebSocketResponse 路由 HttpRouteHandle WebSocketRouteHandle 示例 public class WebSocketDemo { public static void main(String[] args) { //1. 实例化路由Handle WebSocketRouteHandle routeHandle = new WebSocketRouteHandle(); //2. 指定路由规则以及请求的处理实现 routeHandle.route(\"/\", new WebSocketDefaultHandle() { @Override public void handleTextMessage(WebSocketRequest request, WebSocketResponse response, String data) { response.sendTextMessage(\"接受到客户端消息：\" + data); } }); // 3. 启动服务 HttpBootstrap bootstrap = new HttpBootstrap(); bootstrap.wsPipeline().next(routeHandle); bootstrap.start(); } } 运行上述代码后，可以通过 websocket 客户端建立连接并调试接口。此处推荐：在线测试 Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2020-04-02 10:09:31 "},"share/rpc/smart-socket-rpc.html":{"url":"share/rpc/smart-socket-rpc.html","title":"smart-socket实现RPC","keywords":"","body":"smart-socket实现RPC RPC是目前被广泛应用于互联网服务的一项技术，关于它的基本介绍大家可通过百度了解一下，此处不再赘述。 正所谓读万卷书不如行万里路，原理性的文章看的再多都不如亲自实现一遍RPC，方可对其了解的更加透彻。 本文将以纯技术视角，为大家演示一下RPC的工作原理与实现方案。 正式开始之前，先罗列一下实现RPC需要运用到的技术点： 通信 序列化/反序列化 反射 动态代理 在具体实现上除了通信部分我们选用smart-socket来辅助，其余包括序列化/反序列化、反射、动态代理等部分我们将采用JDK提供的解决方案，待您掌握RPC后可再尝试结合第三方技术来重构RPC。 名词解释 Provider RPC服务提供者 Consumer RPC服务调用者 消息通信 既然RPC是跨网络通信服务，那我们先制定通信规则，该部分的内容涉及到通信、序列化/反序列化技术。 通信协议 通信协议我们采用最简单的length+data模式，编解码的实现算法如下。 作为示例我们假设readBuffer足够容纳一个完整的消息，协议中的data部分便是RPC服务序列化后的byte数组，Provider/Consumer则必须对byte数组完成反序列化后才能继续RPC服务处理。 public class RpcProtocol implements Protocol { private static final int INTEGER_BYTES = Integer.SIZE / Byte.SIZE; @Override public byte[] decode(ByteBuffer readBuffer, AioSession session, boolean eof) { int remaining = readBuffer.remaining(); if (remaining remaining) { return null; } byte[] data = new byte[messageSize - INTEGER_BYTES]; readBuffer.getInt(); readBuffer.get(data); return data; } @Override public ByteBuffer encode(byte[] msg, AioSession session) { ByteBuffer byteBuffer = ByteBuffer.allocate(msg.length + INTEGER_BYTES); byteBuffer.putInt(byteBuffer.capacity()); byteBuffer.put(msg); byteBuffer.flip(); return byteBuffer; } } RPC请求消息 RPC请求消息由Consumer发送，Consumer需要在请求消息中提供足够信息以供Provider准确识别服务接口。核心要素包括： uuid 请求消息唯一标识，用于关联、识别响应消息。 interfaceClass Consumer要调用的API接口名 method Consumer要执行的API接口方法名 paramClassList Consumer调用的方法入参类型，用于区分同方法名不同入参的情况 params Consumer执行方法传入的参数值 public class RpcRequest implements Serializable { /** * 消息的唯一标识 */ private final String uuid = UUID.randomUUID().toString(); /** * 接口名称 */ private String interfaceClass; /** * 调用方法 */ private String method; /** * 参数类型字符串 */ private String[] paramClassList; /** * 入参 */ private Object[] params; getX/setX() } RPC响应消息 RPC响应消息为Provider将接口执行结果响应给Consumer的载体。 uuid 与RPC请求消息同值 returnObject RPC接口执行返回值 returnType RPC接口返回值类型 exception RPC执行异常信息，如果出现异常的话。 public class RpcResponse implements Serializable { /** * 消息的唯一标示，与对应的RpcRequest uuid值相同 */ private String uuid; /** * 返回对象 */ private Object returnObject; /** * 返回对象类型 */ private String returnType; /** * 异常 */ private String exception; public RpcResponse(String uuid) { this.uuid = uuid; } getX/setX() } 通过上述内容便完成RPC通信的消息设计，至于RpcRequest、RpcResponse如何转化为通信协议要求的byte数组格式，我们采用JDK提供的序列化方式（生产环境不建议使用）。 序列化ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutput objectOutput = new ObjectOutputStream(byteArrayOutputStream); objectOutput.writeObject(request); aioSession.write(byteArrayOutputStream.toByteArray()); 反序列化ObjectInputStream objectInput = new ObjectInputStream(new ByteArrayInputStream(msg)); RpcResponse resp = (RpcResponse) objectInput.readObject(); RPC服务实现 通过上文方案我们解决了RPC的通信问题，接下来便得根据通信消息实现服务能力。 Consumer 由于RPC的Consumer端只有接口，没有具体实现，但在使用上我们又期望跟本地服务有同样的使用体验。 因此我们需要将接口实例化成对象，并使其具备跨应用服务能力，此处便运用到动态代理。 当Consumer调用RPC接口时，代理类内部发送请求消息至Provider并获取结果。 obj = (T) Proxy.newProxyInstance(getClass().getClassLoader(), new Class[]{remoteInterface}, new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { RpcRequest req = new RpcRequest(); req.setInterfaceClass(remoteInterface.getName()); req.setMethod(method.getName()); Class[] types = method.getParameterTypes(); if (!ArrayUtils.isEmpty(types)) { String[] paramClass = new String[types.length]; for (int i = 0; i Provider Provider可将其提供的RPC服务维护在集合里，采用Map存储即可，key为暴露的接口名，value为接口的具体实现。 一旦Provider接受到RPC的请求消息，只需根据请求消息内容找到并执行对应的服务，最后将返回结果以消息的形式返回至Consumer即可。 ObjectInputStream objectInput = new ObjectInputStream(new ByteArrayInputStream(msg)); RpcRequest req = (RpcRequest) objectInput.readObject(); RpcResponse resp = new RpcResponse(req.getUuid()); try { String[] paramClassList = req.getParamClassList(); Object[] paramObjList = req.getParams(); // 获取入参类型 Class[] classArray = null; if (paramClassList != null) { classArray = new Class[paramClassList.length]; for (int i = 0; i clazz = primitiveClass.get(paramClassList[i]); if (clazz == null) { classArray[i] = Class.forName(paramClassList[i]); } else { classArray[i] = clazz; } } } // 调用接口 Object impObj = impMap.get(req.getInterfaceClass()); if (impObj == null) { throw new UnsupportedOperationException(\"can not find interface: \" + req.getInterfaceClass()); } Method method = impObj.getClass().getMethod(req.getMethod(), classArray); Object obj = method.invoke(impObj, paramObjList); resp.setReturnObject(obj); resp.setReturnType(method.getReturnType().getName()); } catch (InvocationTargetException e) { LOGGER.error(e.getMessage(), e); resp.setException(e.getTargetException().getMessage()); } catch (Exception e) { LOGGER.error(e.getMessage(), e); resp.setException(e.getMessage()); } ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); objectOutput = new ObjectOutputStream(byteArrayOutputStream); objectOutput.writeObject(resp); session.write(byteArrayOutputStream.toByteArray()); 测试RPC服务 服务端定义接口DemoApi，并将其实现示例DemoApiImpl注册至Provider中。 public class Provider { public static void main(String[] args) throws IOException { RpcProviderProcessor rpcProviderProcessor = new RpcProviderProcessor(); AioQuickServer server = new AioQuickServer<>(8888, new RpcProtocol(), rpcProviderProcessor); server.start(); rpcProviderProcessor.publishService(DemoApi.class, new DemoApiImpl()); } } Consumer调用RPC接口test、sum获得执行结果。 public class Consumer { public static void main(String[] args) throws InterruptedException, ExecutionException, IOException { RpcConsumerProcessor rpcConsumerProcessor = new RpcConsumerProcessor(); AioQuickClient consumer = new AioQuickClient<>(\"localhost\", 8888, new RpcProtocol(), rpcConsumerProcessor); consumer.start(); DemoApi demoApi = rpcConsumerProcessor.getObject(DemoApi.class); System.out.println(demoApi.test(\"smart-socket\")); System.out.println(demoApi.sum(1, 2)); } } 总结 本文简要描述了RPC服务实现的关键部分，但是提供稳定可靠的RPC服务还有很多细节需要考虑，有兴趣的朋友可自行研究。 本文示例的完整代码可从smart-socket项目中获取。 Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2018-07-01 19:49:04 "},"share/firstfit/readme.html":{"url":"share/firstfit/readme.html","title":"内存管理-首次适应算法","keywords":"","body":"首次适应算法（First-Fit）在smart-socket中的实践 这是一篇关于内存管理算法的文章，对于Java开发者而言这个话题比较遥远。 虽然我们日常开发中一直在跟内存打交道，但很少关注过内存管理的具体细节，毕竟JVM已经做得很好了。 然而在高并发场景下，程序运行过程中产生的大量内存对象，会造成一定的GC负担，由此直接影响着程序运行性能。如果能缓解一部分GC压力，节省下来的系统资源便会对性能有显著的提升，由此便衍生出了池技术。 本次我们分享的内存池技术主要用于提升网络通信的I/O能力，当然该技术也可用于本地磁盘I/O。比较常见的内存管理算法有以下几种： 首次适应算法（First-Fit） 从空闲分区表的第一个表目起查找该表，把最先能够满足要求的空闲区分配给作业，这种方法目的在于减少查找时间。为适应这种算法，空闲分区表(空闲区链)中的空闲分区要按地址由低到高进行排序。该算法优先使用低址部分空闲区，在低址空间造成许多小的空闲区，在高地址空间保留大的空闲区。 优点 该算法倾向于优先利用内存中低址部分的空闲分区，从而保留了高址部分的大空闲区，这为以后到达的大作业分配大的内存空间创造了条件。 缺点 低址部分不断被划分，会留下许多难以利用的，很小的空闲分区，称为碎片。而每次查找又都是从低址部分开始的，这无疑又会增加查找可用空闲分区时的开销。 最佳适应算法（Best-Fit） 从全部空闲区中找出能满足作业要求的、且大小最小的空闲分区，这种方法能使碎片尽量小。为适应此算法，空闲分区表（空闲区链）中的空闲分区要按从小到大进行排序，自表头开始查找到第一个满足要求的自由分区分配。该算法保留大的空闲区，但造成许多小的空闲区。 最差适应算法（Worst-Fit） 它从全部空闲区中找出能满足作业要求的、且大小最大的空闲分区，从而使链表中的结点大小趋于均匀，适用于请求分配的内存大小范围较窄的系统。为适应此算法，空闲分区表（空闲区链）中的空闲分区要按大小从大到小进行排序，自表头开始查找到第一个满足要求的自由分区分配。该算法保留小的空闲区，尽量减少小的碎片产生。 这些算法各有优劣，本次我们只分享首次适应算法，smart-socket中正是应用了该算法实现的高性能通信。 算法原理 接下来我们通过几个步骤来演示内存申请、释放的过程，以及在此过程中如何导致内存碎片化的产生。 初始状态内存容量为：15 ABCDE先后申请特定大小的内存块：1、2、3、4、5，此时内存池中已无可用空间。 B、D释放内存，内存池中出现两块不相邻的内存块。后续再次申请内存便可从这两块不相邻的内存块中挑选可用空间进行分配。 F申请1字节，G申请2字节。按First-Fit算法，会优先从低位查找可用内存块。当F申请到第2位内存块后，紧邻的3号内存块便不再满足G所需的2字节，所以只能从7~10号内存块中申请2字节。如果内存块小到无法满足应用所需，便成了内存碎片。 A、C、E回收内存，内存池中还原出了大片可用区域。如若F、G也释放内存，则次内存池便恢复如初。 算法实践 内存申请 availableBuffers有序存储了内存池申请/释放过程中产生的内存块。低地址内存块存储于队列头部，高地址存于队列尾部。 申请内存时遍历内存块队列，查找容量足够的内存块。 如果内存块容量刚好符合申请所需大小，则从队列中移除该内存块并返回。 如果内存容量大于申请所需大小，则对该内存块进行拆分。只返回所需大小的内存块，剩余部分存留于队列中。 若无可用内存块，则申请失败，此时只能创建临时内存块。public VirtualBuffer allocate(final int size) { lock.lock(); try { Iterator iterator = availableBuffers.iterator(); VirtualBuffer bufferChunk; while (iterator.hasNext()) { VirtualBuffer freeChunk = iterator.next(); final int remaining = freeChunk.getParentLimit() - freeChunk.getParentPosition(); if (remaining 释放内存 使用完毕的内存块需要主动释放回收，以供下次继续使用。释放的过程主要做到两点： 找到被释放内存块在内存队列中的正确点位。 被释放内存块所处的点位若能与前后相邻内存块形成连续内存块，则合并内存块；反之，则直接放入队列中即可。private void clean0(VirtualBuffer cleanBuffer) { int index = 0; Iterator iterator = availableBuffers.iterator(); while (iterator.hasNext()) { VirtualBuffer freeBuffer = iterator.next(); //cleanBuffer在freeBuffer之前并且形成连续块 if (freeBuffer.getParentPosition() == cleanBuffer.getParentLimit()) { freeBuffer.setParentPosition(cleanBuffer.getParentPosition()); return; } //cleanBuffer与freeBuffer之后并形成连续块 if (freeBuffer.getParentLimit() == cleanBuffer.getParentPosition()) { freeBuffer.setParentLimit(cleanBuffer.getParentLimit()); //判断后一个是否连续 if (iterator.hasNext()) { VirtualBuffer next = iterator.next(); if (next.getParentPosition() == freeBuffer.getParentLimit()) { freeBuffer.setParentLimit(next.getParentLimit()); iterator.remove(); } else if (next.getParentPosition() cleanBuffer.getParentLimit()) { availableBuffers.add(index, cleanBuffer); return; } index++; } availableBuffers.add(cleanBuffer); } 完整代码参阅smart-socket项目中的BufferPage.java 拓展讨论 内存申请/释放在实际应用中还有一个无法回避的问题，那就是并发。如何才能在高并发场景下保证内存池依旧能高效稳定的提供申请与释放服务？ 为了避免多线程并发申请导致某块内存区域被多次分配，必须要对申请的过程加同步锁控制，内存释放的过程亦是如此。 可一旦加上同步锁，内存的申请、释放性能必然受到影响。最为理想的状态是每一个CPU绑定着独立的内存池对象， 运行时便不存在多个CPU对同一个内存池对象进行申请/释放操作，这样便可实现无锁化。 可惜CPU绑定内存池的想法无法实现，只能做到线程级的隔离，采用ThreadLocal便可。只不过此方式如若使用不当可能出现内存泄露，以及内存池资源利用率不高等情况。 为此，推荐的做法是采用数组的方式来维护多个内存池对象，使用时通过某种均衡策略将内存池对象分配给任务作业。 虽然不能杜绝锁竞争的情况发生，但在一定程度上还是可以降低锁机率的。 Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-09-12 13:18:21 "},"share/thread/readme.html":{"url":"share/thread/readme.html","title":"Thread知多少","keywords":"","body":"Thread知多少 线程类Thread是一个非常基础且非常核心的类，所有的的Java项目以及运行进程都跟它有着必然联系。 介绍它的文章不胜枚举，本文将从源码角度对其进行一次深度剖析，或许你会从中了解到自己不曾留意的知识点。 我们将Thread源码中的内容进行了简单规整，大致可分为五大块： 线程状态 过时接口 native接口 静态方法 普通方法 线程状态 新建状态(NEW) 通过new操作符创建Thread对象后，如：new Thread()，线程便处于该状态。 新建状态下的线程是无法主动执行任务：run()方法的。 每个线程必然存在关联的父线程和线程组 线程优先级不会超过归属线程组优先级（参考setPriority算法） 线程初始化阶段很多环节存在同步锁（addUnstarted、nextThreadID、nextThreadNum()），因此实际使用中推荐线程池。 就绪状态(Runnable) 可运行线程的线程状态。处于可运行状态的某一线程正在 Java 虚拟机中运行，但它可能正在等待操作系统中的其他资源，比如处理器。 多次调用start方法会触发IllegalThreadStateException异常 阻塞状态(Blocked) 受阻塞并且正在等待监视器锁的某一线程的线程状态。处于受阻塞状态的某一线程正在等待监视器锁，以便进入一个同步的块/方法，或者在调用 Object.wait 之后再次进入同步的块/方法。 等待状态(WAITING) 某一等待线程的线程状态。某一线程因为调用下列方法之一而处于等待状态： 不带超时值的 Object.wait 不带超时值的 Thread.join LockSupport.park 处于等待状态的线程正等待另一个线程，以执行特定操作。 例如，已经在某一对象上调用了 Object.wait() 的线程正等待另一个线程，以便在该对象上调用 Object.notify() 或 Object.notifyAll()。已经调用了 Thread.join() 的线程正在等待指定线程终止。 限时等待状态(TIMED_WAITING) 具有指定等待时间的某一等待线程的线程状态。某一线程因为调用以下带有指定正等待时间的方法之一而处于定时等待状态： Thread.sleep 带有超时值的 Object.wait 带有超时值的 Thread.join LockSupport.parkNanos LockSupport.parkUntil 死亡状态(TERMINATED) 已终止线程的线程状态。线程已经结束执行。线程结束时JVM会自动调用Thread的私有方法exit以释放资源。 使用ThreadLocal若没有主动remove，在线程任务结束后也会执行内存回收。所谓的内存泄露只存在于长时间处于Runnable状态的线程，例如线程池。 线程状态代码演示 public class ThreadDemo { public static void main(String[] args) throws InterruptedException { Thread t = new Thread(new Runnable() { @Override public void run() { Thread currentThread = Thread.currentThread(); try { System.out.println(\"sleep 150ms\"); Thread.sleep(150); System.out.println(\"sleep 结束\"); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (currentThread) { try { System.out.println(\"wait线程\"); currentThread.wait(); System.out.println(\"wait结束\"); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(currentThread.getState()); System.out.println(\"执行完成\"); } }); //NEW System.out.println(\"当前线程状态\" + t.getState()); t.start(); //TIMED_WAITING Thread.sleep(100); System.out.println(\"当前线程状态\" + t.getState()); Thread.sleep(200); System.out.println(\"当前线程状态\" + t.getState()); synchronized (t) { t.notify(); } Thread.sleep(100); System.out.println(\"当前线程状态\" + t.getState()); } } 过时方法 suspend、resume suspend方法是将一个线程挂起，而resume则是将一个挂起线程复活继续执行，这两个是相互配合的方法。如果这两个方法在某个对象的同步块中执行，会出现死锁。 public class ThreadDemo1 { public static void main(String[] args) { //正常情况 Thread t1 = new Thread(new Runnable() { @Override public void run() { System.out.println(\"挂起\"); Thread.currentThread().suspend(); System.out.println(\"被唤醒了\"); } }); t1.start(); Thread t2 = new Thread(new Runnable() { @Override public void run() { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } t1.resume(); } }); t2.start(); //异常情况 Object lock = new Object(); Thread t3 = new Thread(new Runnable() { @Override public void run() { System.out.println(\"挂起\"); synchronized (lock) { Thread.currentThread().suspend(); } System.out.println(\"被唤醒了\"); } }); t3.start(); Thread t4 = new Thread(new Runnable() { @Override public void run() { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"尝试获取对象锁\"); synchronized (lock) { System.out.println(\"准备resume\"); t3.resume(); } } }); t4.start(); } } stop非常粗暴的停止线程，当前线程可能正在执行关键业务，却被强行终止。 destory 调用该方法会直接异常，想不出设计它的初衷是什么。可能需要看最早期的Java代码才能知道原因。 countStackFrames计算该线程中的堆栈帧数，需要suspend配合才能使用。native方法 currentThread：返回当前正在执行的线程对象 yield：暂停当前正在执行的线程对象，并执行其他线程。 public class TreadDemo3 { public static void main(String[] args) { for (int i = 0; i sleep：在指定的时长内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。该线程不丢失任何监视器的所属权（持有CPU资源）。 isAlive：so easy! holdsLock：如果当前线程在指定的对象上保持监视器锁，则返回 true public class ThreadDemo4 { public static void main(String[] args) { Object object=new Object(); System.out.println(Thread.holdsLock(object)); synchronized (object){ System.out.println(Thread.holdsLock(object)); } System.out.println(Thread.holdsLock(object)); } } isInterrupted dumpThreads：将当前线程的堆栈跟踪打印至标准错误流，就是new了一个异常对象再执行printStackTrace()。 getThreads：反馈当前进程内的所有活动线程，被getAllStackTraces()调用。 setPriority0：将线程优先级设置到操作系统层面。 setNativeName：将线程名称注册到操作系统层面。 静态方法 略，基本没啥好讲的 普通方法 interrupt 中断线程。如果线程在调用 Object 类的 wait()、wait(long) 或 wait(long, int) 方法，或者该类的 join()、join(long)、join(long, int)、sleep(long) 或 sleep(long, int) 方法过程中受阻，则其中断状态将被清除，它还将收到一个 InterruptedException。 public class ThreadDemo5 { public static void main(String[] args) throws InterruptedException { Object lock = new Object(); Thread t = new Thread(new Runnable() { @Override public void run() { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (lock) { try { lock.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } }); t.start(); Thread.sleep(100); t.interrupt(); System.out.println(\"中断t的sleep\"); Thread.sleep(100); t.interrupt(); System.out.println(\"中断t的wait\"); } } join：等待该线程终止。 通过wait接口来实现join功能。如下代码所示当线程t2执行t1.join()后，t2线程阻塞，待t1线程执行完毕后JVM会通过notifyAll来唤醒t2线程。 public class ThreadDemo6 { public static void main(String[] args) { Thread t1 = new Thread(new Runnable() { @Override public void run() { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"thread 1\"); } }); Thread t2 = new Thread(new Runnable() { @Override public void run() { try { t1.join(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"thread 2\"); } }); t1.start(); t2.start(); } } setDaemon 将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，Java 虚拟机退出。该方法必须在启动线程前调用。 setContextClassLoader 返回该线程的上下文 ClassLoader。上下文 ClassLoader 由线程创建者提供，供运行于该线程中的代码在加载类和资源时使用。如果未设定，则默认为父线程的 ClassLoader 上下文。原始线程的上下文 ClassLoader 通常设定为用于加载应用程序的类加载器 getContextClassLoader设置该线程的上下文 ClassLoader。上下文 ClassLoader 可以在创建线程设置，并允许创建者在加载类和资源时向该线程中运行的代码提供适当的类加载器。 涉及到类加载或隔离的项目通常会重置线程中的classLoader. 还有一些边边角角的方法自己去看源码。 Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-07-12 17:20:11 "},"donation.html":{"url":"donation.html","title":"关于捐赠","keywords":"","body":"关于捐赠 如果我们的项目对您的学习有所帮助，持续关注并积极反馈就是对我们最大的支持。 如果我们的项目解决了您工作上的难题，不妨请作者喝杯咖啡吧。 如果您的公司认可我们的开源项目，欢迎各种形式的支持。 捐赠清单 姓名 金额 时间 备注 *平 20 2019-06-28 感谢你的付出 拓荒牛 200 2019-04-12 捐赠一个小红包聊表感谢 goodhans 20 2019-04-08 加油！加油！坚持就是胜利！ chen 20 2019-03-15 钱不多，算是给三哥的开源精神的一点点鼓励 陈旭员 20 2019-03-15 码云捐赠 wbstc 20 2019-03-01 QQ:457319664 *一晗 50 2019-01-08 感谢你的smart文档！感谢你的付出! noear 999 2018-12-27 Tsukasa 100 2018-08-10 noear 200 2018-06-12 萨博 50 2018 逼捐 龙马 50 2018 逼捐 贝尔 50 2018 逼捐 liweibo 99 2018 zhengwen6300 10 2018 刀锋剑雨 20 2018 小仙女 10 2017 捐赠入口 Copyright © smartboot.org 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-06-28 16:52:08 "}}